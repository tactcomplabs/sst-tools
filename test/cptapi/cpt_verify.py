#!/usr/bin/python3

import cpt
import struct
import sys

if __name__ == "__main__":
    # This script specifically checks checkpoint results generated by schema-save.sh.
    # There are 4 components, 4 threads,  and 10 checkpoints generated.
    cpt_pfx_list=[
        "SCHEMA_SAVE_/SCHEMA_SAVE__0_1000000/SCHEMA_SAVE__0_1000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__1_2000000/SCHEMA_SAVE__1_2000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__2_3000000/SCHEMA_SAVE__2_3000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__3_4000000/SCHEMA_SAVE__3_4000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__4_5000000/SCHEMA_SAVE__4_5000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__5_6000000/SCHEMA_SAVE__5_6000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__6_7000000/SCHEMA_SAVE__6_7000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__7_8000000/SCHEMA_SAVE__7_8000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__8_9000000/SCHEMA_SAVE__8_9000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__9_10000000/SCHEMA_SAVE__9_10000000",
        "SCHEMA_SAVE_/SCHEMA_SAVE__10_11000000/SCHEMA_SAVE__10_11000000",
    ]

    for pfx in cpt_pfx_list:
        for rank_thread in ["_0_0", "_0_1", "_0_2", "_0_3"]:
            fn=f"{pfx}{rank_thread}"
            print(f"Loading {fn}.bin using {fn}.schema.json")
            # Create checkpoint object from the checkpoint files
            cptObj = cpt.CPT()
            # Load and check the framing of non-component specific segments
            cptObj.load(f"{fn}.schema.json", f"{fn}.bin")
            # Check our custom component markers
            checkDict = {}
            if rank_thread=="_0_0":
                checkDict['cp_0_0.segcbegin'] =  0xa5a5a5a5a5a5bb0c
                checkDict['cp_0_0.cptBegin'] = 0xffb000000000b1ff
                checkDict['cp_0_0.cptEnd'] = 0xffe000000000e1ff
                checkDict['cp_0_0.segcend'] = 0xa5a5a5a5a5a5ee0c
            elif rank_thread=="_0_1":
                checkDict['cp_0_1.segcbegin'] = 0xa5a5a5a5a5a5bb0c
                checkDict['cp_0_1.cptBegin'] = 0xffb000000001b1ff
                checkDict['cp_0_1.cptEnd'] = 0xffe000000001e1ff
                checkDict['cp_0_1.segcend'] = 0xa5a5a5a5a5a5ee0c
            elif rank_thread=="_0_2":
                checkDict['cp_1_0.segcbegin'] = 0xa5a5a5a5a5a5bb0c
                checkDict['cp_1_0.cptBegin'] = 0xffb000000002b1ff
                checkDict['cp_1_0.cptEnd'] = 0xffe000000002e1ff
                checkDict['cp_1_0.segcend'] = 0xa5a5a5a5a5a5ee0c
            elif rank_thread=="_0_3":
                checkDict['cp_1_1.segcbegin'] = 0xa5a5a5a5a5a5bb0c
                checkDict['cp_1_1.cptBegin'] = 0xffb000000003b1ff
                checkDict['cp_1_1.cptEnd'] = 0xffe000000003e1ff
                checkDict['cp_1_1.segcend'] = 0xa5a5a5a5a5a5ee0c
    
            for s in checkDict:
                print(f"Looking for {s} in {fn}")
                pos = cptObj.getPosition(s)
                type = cptObj.getType(s)
                value = cptObj.getValue(s)
                print(f"{s} type='{type}' pos=0x{pos:x}  value=0x{value[0]:x}")
                if checkDict[s] != value[0]:
                    print(f"ERROR: mismatch E=0x{checkDict[s]:x} A=0x{value[0]:x}", file=sys.stderr)
                    exit(2)

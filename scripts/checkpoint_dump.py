#!/usr/bin/python3

import argparse
import json
import sys
import struct

simple_types = [ "int", "unsigned int", "unsigned long", "unsigned long long"]

# create hierarchical name and convert position to absolute position
g_name2pos = {}
g_name2hash = {}
g_hash2type = {}
g_next_seg_num = 0
g_seg_pos = 0

def seg_info(rec):
    global g_name2pos
    global g_name2hash
    global g_next_seg_num
    global g_seg_pos
    seg_name = rec['seg_name']
    seg_num = int(rec['seg_num'])
    seg_size = int(rec['seg_size'])
    print(f"Processing segment {seg_num} {seg_name} starting at {g_seg_pos} size {seg_size}")
    if (seg_num != g_next_seg_num):
        print(f"seg_num mismatch {g_next_seg_num}", file=sys.stderr)
        exit(1)
    else:
        g_next_seg_num = g_next_seg_num + 1
    names = rec['names']
    for n in names:
        long_name = f"{seg_name}.{n['name']}"
        pos = g_seg_pos + int(n['pos'])
        print(f"\t{n['name']} {n['pos']} -> {long_name} {pos}")
        # save the name, the position, and the type hash
        g_name2pos[long_name] = pos
        g_name2hash[long_name] = int(n['hash_code'], base=16)
    # update base position
    g_seg_pos = g_seg_pos + int(rec['seg_size'])
    #print(g_name2pos)

def type_info(rec):
    global g_hash2type
    for t in rec['type_info']:
        hash_code = int(t['hash_code'],base=16)
        name = t['name']
        size = int(t['size'])
        g_hash2type[hash_code] = name

def main():
    global g_hash2type
    global g_name2pos
    parser = argparse.ArgumentParser()
    
    parser.add_argument("json_file", type=str, help="schema json file generated by SST. Recommend running through c++filter -t first")
    parser.add_argument("cpt_file", type=str, help="checkpoint binary data file")
    
    args = parser.parse_args()

    with open(args.json_file) as schema_file:
        schema = json.load(schema_file);

    chkpt = schema['checkpoint_def']
    seg_count = 0
    for rec in chkpt:
        if rec['rec_type'] == "seg_info":
            seg_info(rec)
        if rec['rec_type'] == "type_info":
            type_info(rec)

    print("# Listing variable name, position, and type\n")
    for n in g_name2pos:
        pos = g_name2pos[n]
        hash = g_name2hash[n]
        typestring = g_hash2type[hash]
        print(f"{n} {pos} {typestring}")

    print(f"\nLoading checkpoint file {args.cpt_file}")
    with open(args.cpt_file, mode='rb') as datafile:
          data = datafile.read()
    
    # set look-up list and expected data
    obj_list = []
    expected = {}

    obj_list.extend(['loaded_libraries.seg1begin']);
    expected['loaded_libraries.seg1begin'] = 0xa5a5a5a5a5a5bb01;
    obj_list.extend(['loaded_libraries.seg1end']);
    expected['loaded_libraries.seg1end'] = 0xa5a5a5a5a5a5ee01;

    obj_list.extend(['simulation_impl.seg2begin']);
    expected['simulation_impl.seg2begin'] = 0xa5a5a5a5a5a5bb02;
    obj_list.extend(['simulation_impl.seg2end']);
    expected['simulation_impl.seg2end'] = 0xa5a5a5a5a5a5ee02;

    obj_list.extend(['cp_0_0.segcbegin']);
    expected['cp_0_0.segcbegin'] = 0xa5a5a5a5a5a5bb0c;
    obj_list.extend(['cp_0_0.segcend']);
    expected['cp_0_0.segcend'] = 0xa5a5a5a5a5a5ee0c;

    obj_list.extend(['cp_0_0.cptBegin']);
    expected['cp_0_0.cptBegin'] = 0xffb000000000b1ff;
    obj_list.extend(['cp_0_0.cptEnd']);
    expected['cp_0_0.cptEnd'] = 0xffe000000000e1ff;

    obj_list.extend(['cp_0_1.cptBegin']);
    expected['cp_0_1.cptBegin'] = 0xffb000000001b1ff;
    obj_list.extend(['cp_0_0.cptEnd']);
    expected['cp_0_1.cptEnd'] = 0xffe000000001e1ff;

    obj_list.extend(['cp_1_0.cptBegin']);
    expected['cp_1_0.cptBegin'] = 0xffb000000002b1ff;
    obj_list.extend(['cp_1_0.cptEnd']);
    expected['cp_1_0.cptEnd'] = 0xffe000000002e1ff;

    obj_list.extend(['cp_1_1.cptBegin']);
    expected['cp_1_1.cptBegin'] = 0xffb000000003b1ff;
    obj_list.extend(['cp_0_0.cptEnd']);
    expected['cp_1_1.cptEnd'] = 0xffe000000003e1ff;
    
    for s in obj_list:
        pos = g_name2pos[s]
        type = g_hash2type[g_name2hash[s]]
        value = struct.unpack_from("Q", data, pos)
        print(f"{s} type='{type}' pos=0x{pos:x}  value=0x{value[0]:x}")
        if expected[s] != value[0]:
            print(f"ERROR: mismatch E=0x{expected[s]:x} A=0x{value[0]:x}", file=sys.stderr)
            exit(2)

if __name__ == "__main__":
    main()
    
